Root cause
	UFO (UDP fragmentation offload): https://www.kernel.org/doc/Documentation/networking/segmentation-offloads.txt
	Khi ta sử dụng hàm send() với cờ MSG_MORE, kernel sẽ hiểu rằng ta sẽ truyền đến nhiều gói tin khác sau đó, kernel sẽ tập hợp các gói tin đó lại thành 1 gói tin lớn
	Cụ thể, trong hàm send đầu tiên, hàm __ip_append_data sẽ tạo socket buffer mới bằng cách gọi hàm ip_ufo_append_data
		static int __ip_append_data(struct sock *sk,
		......
			err = ip_ufo_append_data(sk, queue, getfrag, from, length,
					 hh_len, fragheaderlen, transhdrlen,
					 maxfraglen, flags);
			return 0;
		......
	Tiếp theo, ta update socket vói option SO_NO_CHECK, khiến hàm ip_ufo_append_data không thể được gọi
	Sau đó, ta dùng hàm send() lần 2 để truyền vào 1 gói tin non-UFO vào trong hàm __ip_append_data. Do đã set option SO_NO_CHECK, hàm ip_ufo_append_data sẽ không được gọi mà thay vào đó, ta sẽ tiến vào 1 vòng lặp nhằm chia nhỏ socket buffer. 

		.....
		while (length > 0) {
		/* Check if the remaining data fits into current packet. */
		copy = mtu - skb->len;
		if (copy < length)
			copy = maxfraglen - skb->len;
		if (copy <= 0) {
		.....	
alloc_new_skb:
		.....	
			} else {
				skb = NULL;
				if (refcount_read(&sk->sk_wmem_alloc) <=
				    2 * sk->sk_sndbuf)
					skb = sock_wmalloc(sk,
							   alloclen + hh_len + 15, 1,
							   sk->sk_allocation);
		.....		
			}
		.....	

			if (fraggap) {
				skb->csum = skb_copy_and_csum_bits(
					skb_prev, maxfraglen,
					data + transhdrlen, fraggap, 0);
		.....


	Các giá trị tính toàn trong vòng lặp bị sai dẫn đến kernel sẽ alloc 1 socket buffer mới, sau đó copy payload mà ta đã gửi ở lần send đầu tiên vào sk_buff mới đó bằng hàm skb_copy_and_csum_bits. Tuy nhiên, độ dài của payload > sk_buff mới nên 1 phần dữ liệu sẽ ghi đè lên vùng nhớ phía sau sk_buff, dẫn đến lỗi xảy ra.

	Source code các hàm liên quan: https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/tree/net/ipv4/ip_output.c?id=96d9703050a0036a3360ec98bb41e107c90664fe 

	
-----------------------------------------------------------------------
Exploit
	Như đã trình bày ở phần trên. Lỗi xảy ra tại hàm skb_copy_and_csum_bits khiến dữ liệu phía sau vùng nhớ được cấp phát dành cho sk_buff bị ghi đè. Ta sẽ ghi đè skb_shared_info->destructor_arg bằng địa chỉ shellcode trong user mode

	struct skb_shared_info {
		.....
		uint64_t frag_list;	// struct sk_buff *
		.....
		uint64_t destructor_arg; 				==== point ====> struct ubuf_info {
		.....														uint64_t callback;	// void (*callback)(struct ubuf_info *, bool)		==== point ====> shellcode
	};																......
																}

	Trong quá trình release socket buffer, hàm skb_release_data sẽ gọi destructor_arg->callback, mà địa chỉ của hàm callback có thể được ghi đè theo ý muốn của chúng ta.
	Tuy nhiên, hàm callback được gọi bằng lệnh CALL RAX, nghĩa là việc ta ghi đè được địa chỉ hàm callback chỉ giúp ta control được thanh ghi RAX. 
	Nếu RAX = địa chỉ ROP của lệnh XCHG EAX, ESP RET thì sau khi thực hiện lệnh RET xong, con trỏ lệnh sẽ chỉ tới địa chỉ tương ứng với 8bit thấp trong địa chỉ của lệnh ROP XCHG EAX, ESP RET. Ta đã biết trước địa chỉ của lệnh XCHG EAX, ESP RET nên ta sẽ mmap shellcode vào vùng nhớ có địa chỉ 8bit thấp đó. 
	Shellcode sẽ thực hiện việc disable SMEP bằng cách MOV giá trị thích hợp vào thanh ghi CR4, sau đó chạy lệnh commit_creds( prepare_kernel_cred (0)) để leo quyền root. Ta chỉ bypass được SMEP và không bypass được SMAP.

-----------------------------------------------------------------------
Bypass KASLR
	dùng hàm klogctl(SYSLOG_ACTION_READ_ALL, buffer,...) để đọc tất cả kernel message
	trong kernel message đó ta có thể tìm được 1 địa chỉ thuộc vùng mà kernel được load lên, từ địa chỉ đó ta tính ra được base của kernel
	ta tính sẵn base_address của các ROP và các hàm cần sử dụng. Địa chỉ của các ROP và các hàm khi được load lên = base_kernel + base_address

-----------------------------------------------------------------------
Kiểm tra SMEP và SMAP
	SMEP: Supervisor Mode Execution Protection. 
		Không cho phép kernel thực thi code tại user space
	SMAP: Supervisor Mode Access Prevention
		Không cho phép kernel truy cập vào code tại user space

	Tìm kiếm sự tồn tại của chuỗi 'smep' và 'smap' trong file /proc/cpuinfo

-----------------------------------------------------------------------